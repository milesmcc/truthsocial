{"version":3,"sources":["webpack:///./node_modules/arrow-key-navigation/dist-web/index.js"],"names":["textInputTypes","checkboxRadioInputTypes","focusTrapTest","undefined","getActiveElement","activeElement","document","shadowRoot","getNextNode","root","targetElement","forwardDirection","filter","acceptNode","node","element","matches","disabled","test","getAttribute","hasAttribute","offsetWidth","offsetHeight","NodeFilter","FILTER_ACCEPT","FILTER_SKIP","nextNode","ShadowRoot","toString","includes","nodes","Array","prototype","slice","call","querySelectorAll","idx","indexOf","length","reverse","i","HTMLElement","getNextCandidateNodeForShadowDomPolyfill","walker","createTreeWalker","SHOW_ELEMENT","currentNode","previousNode","lastChild","getNextCandidateNode","host","getRootNode","focusNextOrPrevious","event","key","selectionStart","selectionEnd","len","tagName","isTextarea","isTextInput","toLowerCase","isContentEditable","selection","getSelection","anchorOffset","focusOffset","textContent","value","shouldIgnoreEvent","parent","parentElement","getFocusTrapParent","focus","preventDefault","keyListener","altKey","metaKey","ctrlKey","click","handleEnter","register","addEventListener","unregister","removeEventListener","setFocusTrapTest"],"mappings":"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","file":"js/arrow-key-navigation-bf2dcb8c98689638c96d.chunk.js","sourcesContent":["/**\n * Makes it so the left and right arrows change focus, ala Tab/Shift+Tab. This is mostly designed\n * for KaiOS devices.\n */\n\n/* global document, addEventListener, removeEventListener, getSelection */\n// TODO: email/number types are a special type, in that they return selectionStart/selectionEnd as null\n// As far as I can tell, there is no way to actually get the caret position from these inputs. So we\n// don't do the proper caret handling for those inputs, unfortunately.\n// https://html.spec.whatwg.org/multipage/input.html#do-not-apply\nvar textInputTypes = ['text', 'search', 'url', 'password', 'tel'];\nvar checkboxRadioInputTypes = ['checkbox', 'radio'];\nvar focusTrapTest = undefined; // This query is adapted from a11y-dialog\n// https://github.com/edenspiekermann/a11y-dialog/blob/cf4ed81/a11y-dialog.js#L6-L18\n\nvar focusablesQuery = 'a[href], area[href], input, select, textarea, ' + 'button, iframe, object, embed, [contenteditable], [tabindex], ' + 'video[controls], audio[controls], summary';\n\nfunction getActiveElement() {\n  var activeElement = document.activeElement;\n\n  while (activeElement.shadowRoot) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n\n  return activeElement;\n}\n\nfunction isFocusable(element) {\n  return element.matches(focusablesQuery) && !element.disabled && !/^-/.test(element.getAttribute('tabindex') || '') && !element.hasAttribute('inert') && ( // see https://github.com/GoogleChrome/inert-polyfill\n  element.offsetWidth > 0 || element.offsetHeight > 0);\n}\n\nfunction getFocusTrapParent(element) {\n  if (!focusTrapTest) {\n    return;\n  }\n\n  var parent = element.parentElement;\n\n  while (parent) {\n    if (focusTrapTest(parent)) {\n      return parent;\n    }\n\n    parent = parent.parentElement;\n  }\n}\n\nfunction shouldIgnoreEvent(activeElement, forwardDirection) {\n  var tagName = activeElement.tagName;\n  var isTextarea = tagName === 'TEXTAREA';\n  var isTextInput = tagName === 'INPUT' && textInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1;\n  var isContentEditable = activeElement.hasAttribute('contenteditable');\n\n  if (!isTextarea && !isTextInput && !isContentEditable) {\n    return false;\n  }\n\n  var selectionStart;\n  var selectionEnd;\n  var len;\n\n  if (isContentEditable) {\n    var selection = getSelection();\n    selectionStart = selection.anchorOffset;\n    selectionEnd = selection.focusOffset;\n    len = activeElement.textContent.length;\n  } else {\n    selectionStart = activeElement.selectionStart;\n    selectionEnd = activeElement.selectionEnd;\n    len = activeElement.value.length;\n  } // if the cursor is inside of a textarea/input, then don't focus to the next/previous element\n  // unless the cursor is at the beginning or the end\n\n\n  if (!forwardDirection && selectionStart === selectionEnd && selectionStart === 0) {\n    return false;\n  } else if (forwardDirection && selectionStart === selectionEnd && selectionStart === len) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter) {\n  // When the shadydom polyfill is running, we can't use TreeWalker on ShadowRoots because\n  // they aren't real Nodes. So we do this workaround where we run TreeWalker on the\n  // children instead.\n  var nodes = Array.prototype.slice.call(root.querySelectorAll('*'));\n  var idx = nodes.indexOf(targetElement);\n\n  if (forwardDirection) {\n    nodes = nodes.slice(idx + 1);\n  } else {\n    if (idx === -1) {\n      idx = nodes.length;\n    }\n\n    nodes = nodes.slice(0, idx);\n    nodes.reverse();\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (node instanceof HTMLElement && filter.acceptNode(node) === NodeFilter.FILTER_ACCEPT) {\n      return node;\n    }\n  }\n\n  return undefined;\n}\n\nfunction getNextCandidateNode(root, targetElement, forwardDirection, filter) {\n  var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter);\n\n  if (targetElement) {\n    walker.currentNode = targetElement;\n  }\n\n  if (forwardDirection) {\n    return walker.nextNode();\n  } else if (targetElement) {\n    return walker.previousNode();\n  } // iterating backwards through shadow root, use last child\n\n\n  return walker.lastChild();\n}\n\nfunction isShadowDomPolyfill() {\n  return typeof ShadowRoot !== 'undefined' && ( // ShadowRoot.polyfill is just a hack for our unit tests\n  'polyfill' in ShadowRoot || !ShadowRoot.toString().includes('[native code]'));\n}\n\nfunction getNextNode(root, targetElement, forwardDirection) {\n  var filter = {\n    acceptNode: function acceptNode(node) {\n      return node === targetElement || node.shadowRoot || isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  }; // TODO: remove this when we don't need to support the Shadow DOM polyfill\n\n  var nextNode = isShadowDomPolyfill() && root instanceof ShadowRoot ? getNextCandidateNodeForShadowDomPolyfill(root, targetElement, forwardDirection, filter) : getNextCandidateNode(root, targetElement, forwardDirection, filter);\n\n  if (nextNode && nextNode.shadowRoot) {\n    // push into the shadow DOM\n    return getNextNode(nextNode.shadowRoot, null, forwardDirection);\n  }\n\n  if (!nextNode && root.host) {\n    // pop out of the shadow DOM\n    return getNextNode(root.host.getRootNode(), root.host, forwardDirection);\n  }\n\n  return nextNode;\n}\n\nfunction focusNextOrPrevious(event, key) {\n  var activeElement = getActiveElement();\n  var forwardDirection = key === 'ArrowRight';\n\n  if (shouldIgnoreEvent(activeElement, forwardDirection)) {\n    return;\n  }\n\n  var root = getFocusTrapParent(activeElement) || activeElement.getRootNode();\n  var nextNode = getNextNode(root, activeElement, forwardDirection);\n\n  if (nextNode && nextNode !== activeElement) {\n    nextNode.focus();\n    event.preventDefault();\n  }\n}\n\nfunction handleEnter(event) {\n  var activeElement = getActiveElement();\n\n  if (activeElement.tagName === 'INPUT' && checkboxRadioInputTypes.indexOf(activeElement.getAttribute('type').toLowerCase()) !== -1) {\n    // Explicitly override \"enter\" on an input and make it fire the checkbox/radio\n    activeElement.click();\n    event.preventDefault();\n  }\n}\n\nfunction keyListener(event) {\n  if (event.altKey || event.metaKey || event.ctrlKey) {\n    return; // ignore e.g. Alt-Left and Ctrl-Right, which are used to switch browser tabs or navigate back/forward\n  }\n\n  var key = event.key;\n\n  switch (key) {\n    case 'ArrowLeft':\n    case 'ArrowRight':\n      {\n        focusNextOrPrevious(event, key);\n        break;\n      }\n\n    case 'Enter':\n      {\n        handleEnter(event);\n        break;\n      }\n  }\n}\n/**\n * Start listening for keyboard events. Attaches a listener to the window.\n */\n\n\nfunction register() {\n  addEventListener('keydown', keyListener);\n}\n/**\n * Stop listening for keyboard events. Unattaches a listener to the window.\n */\n\n\nfunction unregister() {\n  removeEventListener('keydown', keyListener);\n}\n/**\n * Set a focus trap test to identify any focus traps in the DOM, i.e. a top-level DOM node that indicates the root\n * of a focus trap. Once this is set, if focus changes within the focus trap, then will not leave the focus trap.\n * @param test: the test function\n * @see https://w3c.github.io/aria-practices/examples/dialog-modal/dialog.html\n */\n\n\nfunction setFocusTrapTest(test) {\n  focusTrapTest = test;\n}\n\nexport { register, setFocusTrapTest, unregister };"],"sourceRoot":""}