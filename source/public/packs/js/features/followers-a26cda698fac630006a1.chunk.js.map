{"version":3,"sources":["webpack:///./app/javascript/mastodon/features/followers/index.js"],"names":["RemoteHint","url","resource","id","defaultMessage","Followers","connect","state","props","remote","getIn","params","accountId","remoteUrl","isAccount","accountIds","hasMore","isLoading","blockedBy","handleLoadMore","dispatch","expandFollowers","leading","componentWillMount","this","fetchAccount","fetchFollowers","componentWillReceiveProps","nextProps","render","emptyMessage","shouldUpdateScroll","multiColumn","isEmpty","remoteMessage","scrollKey","onLoadMore","prepend","hideTabs","alwaysPrepend","append","bindToDocument","map","withNote","ImmutablePureComponent","propTypes","PropTypes","object","isRequired","func","ImmutablePropTypes","list","bool","string"],"mappings":"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","file":"js/features/followers-a26cda698fac630006a1.chunk.js","sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport ImmutablePureComponent from 'react-immutable-pure-component';\nimport PropTypes from 'prop-types';\nimport ImmutablePropTypes from 'react-immutable-proptypes';\nimport { debounce } from 'lodash';\nimport LoadingIndicator from '../../components/loading_indicator';\nimport {\n  fetchAccount,\n  fetchFollowers,\n  expandFollowers,\n} from '../../actions/accounts';\nimport { FormattedMessage } from 'react-intl';\nimport AccountContainer from '../../containers/account_container';\nimport Column from '../ui/components/column';\nimport HeaderContainer from '../account_timeline/containers/header_container';\nimport ColumnBackButton from '../../components/column_back_button';\nimport ScrollableList from '../../components/scrollable_list';\nimport MissingIndicator from 'mastodon/components/missing_indicator';\nimport TimelineHint from 'mastodon/components/timeline_hint';\n\nconst mapStateToProps = (state, props) => ({\n  remote: !!(state.getIn(['accounts', props.params.accountId, 'acct']) !== state.getIn(['accounts', props.params.accountId, 'username'])),\n  remoteUrl: state.getIn(['accounts', props.params.accountId, 'url']),\n  isAccount: !!state.getIn(['accounts', props.params.accountId]),\n  accountIds: state.getIn(['user_lists', 'followers', props.params.accountId, 'items']),\n  hasMore: !!state.getIn(['user_lists', 'followers', props.params.accountId, 'next']),\n  isLoading: state.getIn(['user_lists', 'followers', props.params.accountId, 'isLoading'], true),\n  blockedBy: state.getIn(['relationships', props.params.accountId, 'blocked_by'], false),\n});\n\nconst RemoteHint = ({ url }) => (\n  <TimelineHint url={url} resource={<FormattedMessage id='timeline_hint.resources.followers' defaultMessage='Followers' />} />\n);\n\nRemoteHint.propTypes = {\n  url: PropTypes.string.isRequired,\n};\n\nexport default @connect(mapStateToProps)\nclass Followers extends ImmutablePureComponent {\n\n  static propTypes = {\n    params: PropTypes.object.isRequired,\n    dispatch: PropTypes.func.isRequired,\n    shouldUpdateScroll: PropTypes.func,\n    accountIds: ImmutablePropTypes.list,\n    hasMore: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    blockedBy: PropTypes.bool,\n    isAccount: PropTypes.bool,\n    remote: PropTypes.bool,\n    remoteUrl: PropTypes.string,\n    multiColumn: PropTypes.bool,\n  };\n\n  componentWillMount () {\n    if (!this.props.accountIds) {\n      this.props.dispatch(fetchAccount(this.props.params.accountId));\n      this.props.dispatch(fetchFollowers(this.props.params.accountId));\n    }\n  }\n\n  componentWillReceiveProps (nextProps) {\n    if (nextProps.params.accountId !== this.props.params.accountId && nextProps.params.accountId) {\n      this.props.dispatch(fetchAccount(nextProps.params.accountId));\n      this.props.dispatch(fetchFollowers(nextProps.params.accountId));\n    }\n  }\n\n  handleLoadMore = debounce(() => {\n    this.props.dispatch(expandFollowers(this.props.params.accountId));\n  }, 300, { leading: true });\n\n  render () {\n    const { shouldUpdateScroll, accountIds, hasMore, blockedBy, isAccount, multiColumn, isLoading, remote, remoteUrl } = this.props;\n\n    if (!isAccount) {\n      return (\n        <Column>\n          <MissingIndicator />\n        </Column>\n      );\n    }\n\n    if (!accountIds) {\n      return (\n        <Column>\n          <LoadingIndicator />\n        </Column>\n      );\n    }\n\n    let emptyMessage;\n\n    if (blockedBy) {\n      emptyMessage = <FormattedMessage id='empty_column.account_unavailable' defaultMessage='Profile unavailable' />;\n    } else if (remote && accountIds.isEmpty()) {\n      emptyMessage = <RemoteHint url={remoteUrl} />;\n    } else {\n      emptyMessage = <FormattedMessage id='account.followers.empty' defaultMessage='No one follows this user yet.' />;\n    }\n\n    const remoteMessage = remote ? <RemoteHint url={remoteUrl} /> : null;\n\n    return (\n      <Column>\n        <ColumnBackButton multiColumn={multiColumn} />\n\n        <ScrollableList\n          scrollKey='followers'\n          hasMore={hasMore}\n          isLoading={isLoading}\n          onLoadMore={this.handleLoadMore}\n          shouldUpdateScroll={shouldUpdateScroll}\n          prepend={<HeaderContainer accountId={this.props.params.accountId} hideTabs />}\n          alwaysPrepend\n          append={remoteMessage}\n          emptyMessage={emptyMessage}\n          bindToDocument={!multiColumn}\n        >\n          {blockedBy ? [] : accountIds.map(id =>\n            <AccountContainer key={id} id={id} withNote={false} />,\n          )}\n        </ScrollableList>\n      </Column>\n    );\n  }\n\n}\n"],"sourceRoot":""}