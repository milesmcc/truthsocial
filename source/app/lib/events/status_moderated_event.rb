module Events
  class StatusModeratedEvent
    attr_reader :moderated_by_account, :moderated_status, :decision, :moderation_source, :spam_score, :spam_score_mention_threshold, :spam_score_distribute_threshold, :stored_moderation_result

    def initialize(account_id, status_id, decision, moderation_source, spam_score)
      @moderated_by_account = Account.find(account_id)
      @moderated_status = Status.unscoped.find(status_id)
      @decision = decision.downcase.to_sym
      @moderation_source = moderation_source.downcase.to_sym
      @spam_score = spam_score
      @spam_score_mention_threshold = ENV.fetch('STATUS_SPAM_SCORE_THRESHOLD', 20)
      @spam_score_distribute_threshold = ENV.fetch('STATUS_SPAM_SCORE_THRESHOLD', 80)
    end

    def handle
      return unless moderated_status
      return if skip_update?

      store_moderation_results
      store_analysis
      handle_decision
      handle_distribution
    end

    # Mastodon will update the status with the status.moderated result unless...
    # The status is from an unverified account
    # AND the status is associated with a group
    # AND that group has the sponsored field set to true
    # AND the result is in :ok or :sensitize
    # AND the status.moderated event was generated by an auto_mod account ID

    def skip_update?
      return false unless group_sponsored?
      return false if created_by_owner_of_group?

      !moderated_status.account.verified? and automoderated? and [:ok, :sensitize].include?(decision)
    end

    def moderation_result
      if automoderated?
        return :review if decision == :delete
        return :review if spam_score > spam_score_distribute_threshold && moderated_status.group_id
      end

      return :discard if decision == :delete

      decision
    end

    private

    def created_by_owner_of_group?
      moderated_status&.group&.owner_account_id == moderated_status.account_id
    end

    def group_sponsored?
      moderated_status.group&.sponsored?
    end

    def automoderated?
      moderation_source == :automod
    end

    def store_moderation_results
      @stored_moderation_result = moderated_status.moderation_results.create!(moderation_result: moderation_result)
    end

    def store_analysis
      score = automoderated? ? spam_score : 0 # set to zero if approved by a human
      if moderated_status.analysis.nil?
        moderated_status.create_analysis(spam_score: score)
      else
        moderated_status.analysis.update(spam_score: score)
      end
    end

    def handle_decision
      case decision
      when :ok
        moderated_status.update!(sensitive: false, deleted_at: nil)
      when :sensitize
        moderated_status.update!(sensitive: true, deleted_at: nil)
        Admin::ActionLog.create(account: moderated_by_account, action: :update, target: moderated_status)
        invalidate_cache
      when :delete
        moderated_status.reblogs.update_all(deleted_at: Time.current, deleted_by_id: moderated_by_account.id)
        moderated_status.update!(deleted_at: Time.current, deleted_by_id: moderated_by_account.id)
        RemovalWorker.perform_async(moderated_status.id, redraft: true, notify_user: false, immediate: false)
        invalidate_cache
      end
    end

    def handle_distribution
      return unless status_approved
      previously_approved_result = moderated_status.moderation_results.where.not(created_at: stored_moderation_result.created_at).where(moderation_result: [:ok, :sensitize])
      return if previously_approved_result.exists?

      distribute_status = spam_score <= spam_score_distribute_threshold || !moderated_status.group_id

      PostDistributionService.new.distribute_to_followers(moderated_status) if distribute_status

      Rails.logger.info("StatusModeratedEvent handle_distribution: #{moderated_status.id}, distribute_status: #{distribute_status.inspect}")

      handle_mentions if spam_score <= spam_score_mention_threshold
    end

    def status_approved
      [:ok, :sensitize].include? moderation_result
    end

    def handle_mentions
      mentions = moderated_status.mentions
      return unless mentions

      mention_notifications = Notification.where(activity_id: mentions.pluck(:id)).exists?
      return if mention_notifications

      mentions.each { |mention| ProcessMentionsService.create_notification(moderated_status, mention) }
    end

    def invalidate_cache
      Rails.cache.delete(moderated_status)
      InvalidateSecondaryCacheService.new.call('InvalidateStatusCacheWorker', moderated_status.id)
    end
  end
end
